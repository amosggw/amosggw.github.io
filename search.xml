<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap对HashCode碰撞的处理及源码解析]]></title>
    <url>%2F2018%2F04%2F26%2Fhashmap%2F</url>
    <content type="text"><![CDATA[HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 什么是拉链法 怎么解决冲突拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。简而言之：HashCode是使用Key通过Hash函数计算出来的，由于不同的Key，通过此Hash函数可能会算的同样的HashCode，所以此时用了拉链法解决冲突，把HashCode相同的Value连成链表，但是get的时候根据Key又去桶里找，如果是链表说明是冲突的，此时还需要检测Key是否相同 源码解析（基于jdk1.8）成员变量//默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //Entry链表最大长度，大于该长度，将链表转化为红黑树存储(JDK1.8新增) static final int TREEIFY_THRESHOLD = 8; //Entry链表小于该长度，将红黑树转化为链表(JDK1.8新增) static final int UNTREEIFY_THRESHOLD = 6; //转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，总是2的幂 transient Node&lt;K,V&gt;[] table; //存放具体元素的Set transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //记录HashMap发生结构性变化的次数(value覆盖不属于结构性变化) transient int modCount; //扩容的时候下一个table大小的值，(table.length * load factor) //size大于这个值会进行resize()扩容 int threshold; //记录HashMap装载因子 final float loadFactor; 构造函数／** *指定“容量大小”和“加载因子”的构造函数 *／ public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } /** *指定“容量大小”的构造函数 */ public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } /** * 默认构造函数 * (16) and the default load factor (0.75). */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } /** * 包含“子Map”的构造函数 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } 说明：table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。size是HashMap的大小，它是HashMap保存的键值对的数量。threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。oadFactor就是加载因子。modCount是用来实现fail-fast机制的。 添加元素//put方法，如果key存在，新value替换原来存在的value //将key做了一次hash，得到hash值 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } //putIfAbsent与put方法都调用putVal，唯一区别是，第三个参数，一个是false，一个是true，如果为true，不改变已经存在的key。 public V putIfAbsent(K key, V value) { return putVal(hash(key), key, value, true, true); } //onlyIfAbsent 如果为true，不改变已经存在的key。 //evict 如果false，table处于creation mode。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) { //如果table为空，需要初始化 n = (tab = resize()).length; } //根据hash值确定节点在数组中插入的位置，如果该位置没有元素则插入 //因为n总是2的幂，i=hash%n if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果该位置有元素 else { Node&lt;K,V&gt; e; K k; //比较旧元素和待插入元素的hash值和key值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果旧元素是红黑树节点，调用putTreeVal() else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //旧元素为链表节点，寻找插入位置 else { for (int binCount = 0; ; ++binCount) { //如果找到插入位置，插入新节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //如果链表节点超过TREEIFY_THRESHOLD - 1，链表转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果链表中节点的key值与插入元素的key值相等则break if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //用来遍历链表，和e=p.next组合 p = e; } } //在数组中找到key，hash与待插入元素相等的节点 if (e != null) { // existing mapping for key //记录e的value V oldValue = e.value; //onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //新值替换 e.value = value; //访问后回调 afterNodeAccess(e); // return oldValue; } } ++modCount; //实际大小大于threshold，扩容 if (++size &gt; threshold) resize(); //插入后回调 afterNodeInsertion(evict); return null; } //初始化，或者扩容的方法， final Node&lt;K,V&gt;[] resize() { //记录下旧的table Node&lt;K,V&gt;[] oldTab = table; //如果旧的table为空，oldCap为0，不为空，oldCap为旧table的大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; //记录旧的扩容值，默认0 int oldThr = threshold; //定义了newCap，newThr为0 int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { //oldCap比最大容量大，threshold为int最大值 threshold = Integer.MAX_VALUE; return oldTab; } //如果当前容量小于最大容量，并且扩容过或者准备扩容，那么newThr翻一倍。 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; } //如果oldThr大于0，oldThr就是newCap的大小 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { //如果oldCap和oldThr都为0，就会在这里赋值newCap为16，newThr为12 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } //如果新的阀值为0，需要计算新的阀值 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } //设置新的阀值 threshold = newThr; //创建新的桶 //@SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { //将oldTab中的节点reHash到newTab里面 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; //如果节点是单个节点，则直接在newTab里面进行重定位 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果节点是TreeNode节点，要进行红黑树的rehash操作 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //如果是链表，进行链表的rehash操作 else { // preserve order //一个桶中有多个元素，遍历将它们移到新的bucket或者不改变 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; //根据e.hash&amp;oldCap 判断节点位置rehash后是否发生改变 if ((e.hash &amp; oldCap) == 0) {//不改变 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } //放到新的bucket else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; //rehash后新节点的位置为原来基础上加上oldCap newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } //hash冲突的情况： //1.两节点key值相同，则hash值相同，冲突 //2.两节点key值不同，hash值相同，冲突 //3.两节点key值不同，hash不同，在对数组取模后相同，冲突 final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; //从根节点开始查找合适的位置 for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) &gt; h) //dir小于0，查找当前节点的左子节点 dir = -1; else if (ph &lt; h) //dir大于0，查找当前节点的右子节点 dir = 1; //如果hash值相同，key相同 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; //当前节点与待插入节点key不同，hash值相同 //k没有实现Comparable接口 //pk为空，或者k.compareTo(pk)返回值为0 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { // if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } //如果k不可比较，走这里进行比较 dir = tieBreakOrder(k, pk); } //xp记录当前节点父节点 TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { //找到待插入的位置 Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; //插入后，要进行树的平衡 moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; //如果tab=null或者tab的长度小于MIN_TREEIFY_CAPACITY(64) 进行扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); //否则将链表转化为红黑树 else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } 获取元素//根据key获取元素 public V get(Object key) { Node&lt;K,V&gt; e; //对key进行hash后，根据hash值和key进行查找 return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //通过 hash&amp;(n-1) 得到元素的保存位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { //检查第一个节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { //如果是红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { //如果是链表 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } //从根节点开始查找 final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java跳槽必备复习知识点]]></title>
    <url>%2F2018%2F04%2F25%2Fjava-skill%2F</url>
    <content type="text"><![CDATA[跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。好的，现在进入正文。 1、明确项目是做什么的 2、明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？） 3、明确项目的功能。（这个项目涉及哪些功能？） 4、明确项目的技术。（这个项目用到哪些技术？） 5、明确个人在项目中的位置和作用。（你在这个项目的承担角色？） 6、明确项目的整体架构。 7、明确项目的优缺点,如果重新设计你会如何设计。 8、明确项目的亮点。（这个项目有什么亮点？） 9、明确技术成长。（你通过这个项目有哪些技术成长？） Java基础 1、List 和 Set 的区别 2、HashSet 是如何保证不重复的 3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）? 4、HashMap 的扩容过程 5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？ 6、final finally finalize 7、强引用 、软引用、 弱引用、虚引用 8、Java反射 9、Arrays.sort 实现原理和 Collection 实现原理 10、LinkedHashMap的应用 11、cloneable接口实现原理 12、异常分类以及处理机制 13、wait和sleep的区别 14、数组在内存中如何分配 Java 并发 1、synchronized 的实现原理以及锁优化？ 2、volatile 的实现原理？ 3、Java 的信号灯？ 4、synchronized 在静态方法和普通方法的区别？ 5、怎么实现所有线程在等待某个事件的发生才会去执行？ 6、CAS？CAS 有什么缺陷，如何解决？ 7、synchronized 和 lock 有什么区别？ 8、Hashtable 是怎么加锁的 ？ 9、HashMap 的并发问题？ 10、ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？ 11、AQS 12、如何检测死锁？怎么预防死锁？ 13、Java 内存模型？ 14、如何保证多线程下 i++ 结果正确？ 15、线程池的种类，区别和使用场景？ 16、分析线程池的实现原理和线程的调度过程？ 17、线程池如何调优，最大数目如何确认？ 18、ThreadLocal原理，用的时候需要注意什么？ 19、CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别? 20、LockSupport工具 21、Condition接口及其实现原理 22、Fork/Join框架的理解 23、分段锁的原理,锁力度减小的思考 24、八种阻塞队列以及各个阻塞队列的特性 Spring 1、BeanFactory 和 FactoryBean？ 2、Spring IOC 的理解，其初始化过程？ 3、BeanFactory 和 ApplicationContext？ 4、Spring Bean 的生命周期，如何被管理的？ 5、Spring Bean 的加载过程是怎样的？ 6、如果要你实现Spring AOP，请问怎么实现？ 7、如果要你实现Spring IOC，你会注意哪些问题？ 8、Spring 是如何管理事务的，事务管理机制？ 9、Spring 的不同事务传播行为有哪些，干什么用的？ 10、Spring 中用到了那些设计模式？ 11、Spring MVC 的工作原理？ 12、Spring 循环注入的原理？ 13、Spring AOP的理解，各个术语，他们是怎么相互工作的？ 14、Spring 如何保证 Controller 并发的安全？ Netty 1、BIO、NIO和AIO 2、Netty 的各大组件 3、Netty的线程模型 4、TCP 粘包/拆包的原因及解决方法 5、了解哪几种序列化协议？包括使用场景和如何去选择 6、Netty的零拷贝实现 7、Netty的高性能表现在哪些方面 分布式相关 1、Dubbo的底层实现原理和机制 2、描述一个服务从发布到被消费的详细过程 3、分布式系统怎么做服务治理 4、接口的幂等性的概念 5、消息中间件如何解决消息丢失问题 6、Dubbo的服务请求失败怎么处理 7、重连机制会不会造成错误 8、对分布式事务的理解 9、如何实现负载均衡，有哪些算法可以实现？ 10、Zookeeper的用途，选举的原理是什么？ 11、数据的垂直拆分水平拆分。 12、zookeeper原理和适用场景 13、zookeeper watch机制 14、redis/zk节点宕机如何处理 15、分布式集群下如何做到唯一序列号 16、如何做一个分布式锁 17、用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 18、MQ系统的数据如何保证不丢失 19、列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题 20、zookeeper的选举策略 21、全局ID 数据库 1、mysql分页有什么优化 2、悲观锁、乐观锁 3、组合索引，最左原则 4、mysql 的表锁、行锁 5、mysql 性能优化 6、mysql的索引分类：B+，hash；什么情况用什么索引 7、事务的特性和隔离级别 缓存 1、Redis用过哪些数据数据，以及Redis底层怎么实现 2、Redis缓存穿透，缓存雪崩 3、如何使用Redis来实现分布式锁 4、Redis的并发竞争问题如何解决 5、Redis持久化的几种方式，优缺点是什么，怎么实现的 6、Redis的缓存失效策略 7、Redis集群，高可用，原理 8、Redis缓存分片 9、Redis的数据淘汰策略 JVM 1、详细jvm内存模型 2、讲讲什么情况下回出现内存溢出，内存泄漏？ 3、说说Java线程栈 4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？ 5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？ 6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？ 7、类的实例化顺序 8、JVM垃圾回收机制，何时触发MinorGC等操作 9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的 10、各种回收器，各自优缺点，重点CMS、G1 11、各种回收算法 12、OOM错误，stackoverflow错误，permgen space错误]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
